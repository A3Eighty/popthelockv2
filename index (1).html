<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pop the Lock Clone</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <style>
        body {
            touch-action: none; /* Prevent zoom/scroll on mobile */
            background-color: #111827; /* Gray 900 */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
        }
        canvas {
            display: block;
            margin: 0 auto;
        }
        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        .header-ui {
            position: absolute;
            top: 10%; /* Positioned near top */
            width: 100%;
            text-align: center;
            pointer-events: none;
        }
        .interactive {
            pointer-events: auto;
        }
        /* Arcade font style for score */
        .arcade-font {
            font-family: 'Courier New', Courier, monospace;
            letter-spacing: -2px;
        }
    </style>
</head>
<body class="h-screen w-screen text-white select-none">

    <!-- Header UI (Always visible or top layer) -->
    <div class="header-ui flex flex-col items-center z-10">
        <h1 id="gameTitle" class="text-5xl md:text-6xl font-black transition-colors duration-300 drop-shadow-[0_0_10px_rgba(250,204,21,0.5)] tracking-wider uppercase">POP THE LOCK</h1>
        <p id="gameInstruction" class="mt-4 text-sm md:text-base max-w-md px-4 font-medium tracking-wide transition-colors duration-300">
            TAP WHEN THE <span id="instrBar" class="font-bold transition-colors duration-300">BAR</span> HITS THE <span id="instrDot" class="font-bold transition-colors duration-300">DOT</span>
        </p>
    </div>

    <!-- Canvas for the game -->
    <canvas id="gameCanvas" class="absolute top-0 left-0 z-0"></canvas>

    <!-- Center UI Overlay (Start/End screens + Score) -->
    <div id="uiLayer" class="ui-overlay z-20">
        
        <!-- Score Display (In the center of the lock) -->
        <div id="scoreDisplay" class="text-9xl font-black text-white hidden drop-shadow-lg select-none" style="font-family: 'Segoe UI', sans-serif;">50</div>
        
        <div id="startScreen" class="flex flex-col items-center mt-32 transition-opacity duration-300">
            <button id="startBtn" class="interactive bg-yellow-500 hover:bg-yellow-400 text-black font-black py-4 px-12 rounded-full text-2xl shadow-[0_0_20px_rgba(234,179,8,0.6)] transition transform hover:scale-110 active:scale-95 border-4 border-yellow-300 mb-6">
                PLAY
            </button>
            <button id="settingsBtn" class="interactive bg-gray-700 hover:bg-gray-600 text-white font-bold py-3 px-8 rounded-full text-lg shadow-lg transition transform hover:scale-105 active:scale-95 border-2 border-gray-500">
                SETTINGS
            </button>
        </div>

        <!-- Settings Screen -->
        <div id="settingsScreen" class="hidden flex-col items-center bg-gray-900/95 p-8 rounded-2xl border-2 border-gray-700 shadow-2xl max-w-md w-full mx-4 backdrop-blur-sm interactive max-h-[80vh] overflow-y-auto">
            <h2 class="text-3xl text-white font-black mb-6 tracking-wider uppercase">SETTINGS</h2>
            
            <div class="w-full mb-6">
                <h3 class="text-gray-400 text-sm font-bold mb-3 uppercase tracking-wide">THEME</h3>
                <div class="grid grid-cols-2 gap-3" id="themeGrid">
                    <!-- Themes injected by JS -->
                </div>
            </div>
            
            <div class="w-full mb-8">
                <h3 class="text-gray-400 text-sm font-bold mb-3 uppercase tracking-wide">DIFFICULTY</h3>
                <div class="flex justify-between gap-2 bg-gray-800 p-1 rounded-lg" id="diffGrid">
                    <!-- Difficulty buttons injected by JS -->
                </div>
            </div>
            
            <button id="closeSettingsBtn" class="w-full bg-gray-700 hover:bg-gray-600 text-white font-bold py-3 rounded-lg transition">
                DONE
            </button>
        </div>

        <div id="gameOverScreen" class="hidden flex-col items-center mt-32">
            <h2 class="text-4xl text-red-500 font-black mb-2 drop-shadow-md">GAME OVER</h2>
            <p id="finalScore" class="text-2xl text-gray-300 mb-8 font-mono">Remaining: 50</p>
            <button id="retryBtn" class="interactive bg-white hover:bg-gray-200 text-black font-bold py-3 px-10 rounded-full text-xl shadow-lg transition transform hover:scale-105 active:scale-95">
                TRY AGAIN
            </button>
            <button id="menuBtn" class="interactive mt-4 text-gray-400 hover:text-white font-bold py-2 px-6 transition text-sm uppercase tracking-wider">
                MAIN MENU
            </button>
        </div>
        
        <div id="winScreen" class="hidden flex-col items-center mt-32">
            <h2 class="text-5xl text-green-500 font-black mb-2 drop-shadow-[0_0_10px_rgba(34,197,94,0.8)]">UNLOCKED!</h2>
            <p class="text-xl text-gray-300 mb-8">Excellent Coordination!</p>
            <button id="playAgainBtn" class="interactive bg-yellow-500 hover:bg-yellow-400 text-black font-bold py-3 px-10 rounded-full text-xl shadow-lg transition transform hover:scale-105 active:scale-95">
                PLAY AGAIN
            </button>
            <button id="menuBtnWin" class="interactive mt-4 text-gray-400 hover:text-white font-bold py-2 px-6 transition text-sm uppercase tracking-wider">
                MAIN MENU
            </button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // UI Elements
        const uiLayer = document.getElementById('uiLayer');
        const startScreen = document.getElementById('startScreen');
        const settingsScreen = document.getElementById('settingsScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const winScreen = document.getElementById('winScreen');
        const scoreDisplay = document.getElementById('scoreDisplay');
        
        const startBtn = document.getElementById('startBtn');
        const settingsBtn = document.getElementById('settingsBtn');
        const closeSettingsBtn = document.getElementById('closeSettingsBtn');
        const retryBtn = document.getElementById('retryBtn');
        const playAgainBtn = document.getElementById('playAgainBtn');
        const menuBtn = document.getElementById('menuBtn');
        const menuBtnWin = document.getElementById('menuBtnWin');
        const finalScoreEl = document.getElementById('finalScore');
        
        // New Header UI Elements
        const gameTitle = document.getElementById('gameTitle');
        const gameInstruction = document.getElementById('gameInstruction');
        const instrBar = document.getElementById('instrBar');
        const instrDot = document.getElementById('instrDot');
        
        const themeGrid = document.getElementById('themeGrid');
        const diffGrid = document.getElementById('diffGrid');

        // Data
        const THEMES = {
            'ARCADE': { name: 'Arcade', bg: '#111827', lock: '#374151', target: '#facc15', ticker: '#ef4444', text: '#ffffff', progress: '#22c55e' },
            'MINIMAL': { name: 'Minimal', bg: '#e5e7eb', lock: '#9ca3af', target: '#3b82f6', ticker: '#1f2937', text: '#1f2937', progress: '#059669' },
            'NEON': { name: 'Neon', bg: '#000000', lock: '#262626', target: '#00ff00', ticker: '#ff00ff', text: '#00ff00', progress: '#00ff00' },
            'OCEAN': { name: 'Ocean', bg: '#0f172a', lock: '#1e293b', target: '#38bdf8', ticker: '#f472b6', text: '#e0f2fe', progress: '#2dd4bf' },
            'VAPOR': { name: 'Vapor', bg: '#2d1b4e', lock: '#4c1d95', target: '#00ffff', ticker: '#ff00ff', text: '#f3e8ff', progress: '#00ffff' },
            'FOREST': { name: 'Forest', bg: '#14532d', lock: '#166534', target: '#a3e635', ticker: '#fbbf24', text: '#f0fdf4', progress: '#4ade80' },
            'SUNSET': { name: 'Sunset', bg: '#431407', lock: '#7c2d12', target: '#fb923c', ticker: '#fde047', text: '#fff7ed', progress: '#f97316' },
            'MONO': { name: 'Mono', bg: '#171717', lock: '#404040', target: '#ffffff', ticker: '#a3a3a3', text: '#fafafa', progress: '#ffffff' }
        };

        const DIFFICULTIES = {
            'EASY': { label: 'Chill', speed: 0.0015, inc: 0.00008, tol: 0.35 },
            'NORMAL': { label: 'Normal', speed: 0.0020, inc: 0.00012, tol: 0.28 },
            'HARD': { label: 'Sweaty', speed: 0.0028, inc: 0.00018, tol: 0.22 }
        };

        // State
        let activeTheme = 'ARCADE';
        let activeDifficulty = 'NORMAL';
        
        let gameState = 'IDLE'; 
        let score = 0;
        const MAX_SCORE = 50;
        
        let centerX, centerY, radius;
        let angle = 0; 
        let velocity = 0; 
        let targetAngle = 0; 
        let direction = 1; 
        let lastTime = 0;
        let lastHitTime = 0;

        // Audio
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();
        
        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            osc.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            
            const now = audioCtx.currentTime;
            
            if (type === 'pop') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(800, now);
                osc.frequency.exponentialRampToValueAtTime(1200, now + 0.08);
                gainNode.gain.setValueAtTime(0.4, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.08);
                osc.start();
                osc.stop(now + 0.08);
            } else if (type === 'fail') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(150, now);
                osc.frequency.linearRampToValueAtTime(80, now + 0.4);
                gainNode.gain.setValueAtTime(0.4, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
                osc.start();
                osc.stop(now + 0.4);
            } else if (type === 'win') {
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(523.25, now); 
                osc.frequency.setValueAtTime(659.25, now + 0.1); 
                osc.frequency.setValueAtTime(783.99, now + 0.2); 
                osc.frequency.setValueAtTime(1046.50, now + 0.3); 
                
                gainNode.gain.setValueAtTime(0.3, now);
                gainNode.gain.linearRampToValueAtTime(0, now + 0.8);
                osc.start();
                osc.stop(now + 0.8);
            }
        }
        
        // Initialization
        function initMenus() {
            // Themes
            themeGrid.innerHTML = '';
            for (const [key, theme] of Object.entries(THEMES)) {
                const btn = document.createElement('button');
                btn.className = `p-3 rounded-lg font-bold text-sm uppercase tracking-wide transition transform hover:scale-105 border-2 ${activeTheme === key ? 'border-white ring-2 ring-offset-2 ring-offset-gray-900 ring-blue-500' : 'border-transparent'}`;
                btn.style.backgroundColor = theme.bg;
                btn.style.color = theme.target;
                btn.style.borderColor = theme.lock;
                btn.innerText = theme.name;
                btn.onclick = () => setTheme(key);
                themeGrid.appendChild(btn);
            }
            
            // Difficulty
            diffGrid.innerHTML = '';
            for (const [key, diff] of Object.entries(DIFFICULTIES)) {
                const btn = document.createElement('button');
                btn.className = `flex-1 py-2 rounded-md font-bold text-sm transition ${activeDifficulty === key ? 'bg-blue-600 text-white shadow-md' : 'text-gray-400 hover:text-white hover:bg-gray-700'}`;
                btn.innerText = diff.label;
                btn.onclick = () => setDifficulty(key);
                diffGrid.appendChild(btn);
            }
        }
        
        function setTheme(key) {
            activeTheme = key;
            const t = THEMES[key];
            document.body.style.backgroundColor = t.bg;
            document.body.style.color = t.text;
            
            // Update Title & Instructions to match theme
            if (gameTitle) {
                gameTitle.style.color = t.target;
                gameTitle.style.textShadow = `0 0 15px ${t.target}80`; 
            }
            if (gameInstruction) {
                gameInstruction.style.color = t.text;
                gameInstruction.style.opacity = '0.8';
            }
            if (instrBar) {
                instrBar.style.color = t.ticker;
            }
            if (instrDot) {
                instrDot.style.color = t.target;
            }
            
            initMenus(); // Re-render to update active state
            draw();
        }
        
        function setDifficulty(key) {
            activeDifficulty = key;
            initMenus();
        }

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            centerX = canvas.width / 2;
            centerY = canvas.height / 2;
            radius = Math.min(canvas.width, canvas.height) * 0.22;
        }
        
        window.addEventListener('resize', resize);
        resize();
        initMenus();

        function startGame() {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            gameState = 'PLAYING';
            score = 0;
            angle = -Math.PI / 2; 
            direction = 1; 
            lastHitTime = 0; 
            
            // Apply difficulty
            const diff = DIFFICULTIES[activeDifficulty];
            velocity = diff.speed;
            
            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            winScreen.classList.add('hidden');
            
            scoreDisplay.classList.remove('hidden');
            scoreDisplay.innerText = MAX_SCORE - score;
            
            spawnTarget();
            
            setTimeout(() => {
                window.addEventListener('pointerdown', handleInput);
                window.addEventListener('keydown', handleKeyInput);
            }, 200);
            
            lastTime = performance.now();
            requestAnimationFrame(loop);
        }

        function returnToMenu() {
            gameState = 'IDLE';
            scoreDisplay.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            winScreen.classList.add('hidden');
            startScreen.classList.remove('hidden');
            
            window.removeEventListener('pointerdown', handleInput);
            window.removeEventListener('keydown', handleKeyInput);
            
            draw();
        }

        function openSettings() {
            startScreen.classList.add('opacity-0', 'pointer-events-none');
            settingsScreen.classList.remove('hidden');
            settingsScreen.classList.add('flex');
        }
        
        function closeSettings() {
            settingsScreen.classList.add('hidden');
            settingsScreen.classList.remove('flex');
            startScreen.classList.remove('opacity-0', 'pointer-events-none');
        }

        function spawnTarget() {
            let valid = false;
            while (!valid) {
                targetAngle = Math.random() * Math.PI * 2;
                let diff = Math.abs(getAngleDifference(angle, targetAngle));
                if (diff > 1.0 && diff < 4.5) { 
                    valid = true;
                }
            }
        }
        
        function gameOver() {
            gameState = 'GAMEOVER';
            window.removeEventListener('pointerdown', handleInput);
            window.removeEventListener('keydown', handleKeyInput);
            
            scoreDisplay.classList.add('hidden');
            gameOverScreen.classList.remove('hidden');
            finalScoreEl.innerText = 'Remaining: ' + (MAX_SCORE - score);
            
            const intensity = 10;
            canvas.style.transform = `translate(${intensity}px, ${intensity}px)`;
            setTimeout(() => canvas.style.transform = `translate(-${intensity}px, -${intensity}px)`, 50);
            setTimeout(() => canvas.style.transform = `translate(${intensity}px, -${intensity}px)`, 100);
            setTimeout(() => canvas.style.transform = 'translate(0, 0)', 150);
        }
        
        function gameWin() {
            gameState = 'WON';
            window.removeEventListener('pointerdown', handleInput);
            window.removeEventListener('keydown', handleKeyInput);
            
            scoreDisplay.classList.add('hidden');
            winScreen.classList.remove('hidden');
        }

        function handleInput(e) {
            if (gameState !== 'PLAYING') return;
            
            const diffVal = getAngleDifference(angle, targetAngle);
            const currentDiffSettings = DIFFICULTIES[activeDifficulty];
            
            if (Math.abs(diffVal) <= currentDiffSettings.tol) {
                score++;
                lastHitTime = performance.now();
                scoreDisplay.innerText = MAX_SCORE - score;
                
                if (score >= MAX_SCORE) {
                    playSound('win');
                    gameWin();
                    return;
                }
                
                playSound('pop');
                
                direction *= -1;
                velocity = (currentDiffSettings.speed + (score * currentDiffSettings.inc)) * direction;
                
                const minDist = Math.PI / 3; 
                const maxDist = Math.PI * 1.5; 
                const range = maxDist - minDist;
                const dist = minDist + (Math.random() * range);
                
                targetAngle = angle + (dist * direction);
                targetAngle = targetAngle % (Math.PI * 2);
                if (targetAngle < 0) targetAngle += Math.PI * 2;
                
            } else {
                playSound('fail');
                gameOver();
            }
        }
        
        function handleKeyInput(e) {
            if (e.code === 'Space' || e.code === 'Enter') {
                handleInput();
            }
        }
        
        function getAngleDifference(a1, a2) {
            let diff = (a2 - a1 + Math.PI) % (Math.PI * 2) - Math.PI;
            if (diff < -Math.PI) diff += Math.PI * 2;
            return diff;
        }
        
        function loop(timestamp) {
            if (gameState !== 'PLAYING') {
                draw();
                return;
            }
            
            const dt = timestamp - lastTime;
            lastTime = timestamp;
            const safeDt = Math.min(dt, 50);
            
            angle += velocity * safeDt;
            angle = angle % (Math.PI * 2);
            if (angle < 0) angle += Math.PI * 2;
            
            draw();
            requestAnimationFrame(loop);
        }
        
        function draw() {
            const t = THEMES[activeTheme];
            const now = performance.now();
            const timeSinceHit = now - lastHitTime;
            const flashDuration = 400;
            const isFlashing = timeSinceHit < flashDuration;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Lock Body Base (Permanent)
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.lineWidth = 50; 
            ctx.strokeStyle = t.lock;
            ctx.stroke();

            // Flash Outlines
            if (isFlashing) {
                ctx.save();
                const progress = timeSinceHit / flashDuration;
                const alpha = 0.8 * (1 - progress);
                
                ctx.globalAlpha = alpha;
                ctx.globalCompositeOperation = 'lighter';
                
                ctx.lineWidth = 6;
                ctx.strokeStyle = t.progress;
                ctx.shadowColor = t.progress;
                ctx.shadowBlur = 50;
                
                // Outer rim ONLY
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius + 28, 0, Math.PI * 2);
                ctx.stroke();
                
                ctx.restore();
            }
            
            // Target Dot
            const targetX = centerX + Math.cos(targetAngle) * radius;
            const targetY = centerY + Math.sin(targetAngle) * radius;
            
            ctx.beginPath();
            ctx.arc(targetX, targetY, 32, 0, Math.PI * 2);
            ctx.fillStyle = t.target;
            ctx.shadowColor = t.target;
            ctx.shadowBlur = 25;
            ctx.fill();
            ctx.shadowBlur = 0; 
            
            // Ticker
            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.rotate(angle);
            ctx.translate(radius, 0);
            
            ctx.fillStyle = t.ticker;
            ctx.shadowColor = t.ticker;
            ctx.shadowBlur = 15;
            
            roundRect(ctx, -40, -10, 80, 20, 10); 
            
            ctx.fill();
            ctx.restore();
        }
        
        function roundRect(ctx, x, y, w, h, r) {
            if (w < 2 * r) r = w / 2;
            if (h < 2 * r) r = h / 2;
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.arcTo(x + w, y, x + w, y + h, r);
            ctx.arcTo(x + w, y + h, x, y + h, r);
            ctx.arcTo(x, y + h, x, y, r);
            ctx.arcTo(x, y, x + w, y, r);
            ctx.closePath();
        }

        // Listeners
        startBtn.addEventListener('click', startGame);
        retryBtn.addEventListener('click', startGame);
        playAgainBtn.addEventListener('click', startGame);
        
        settingsBtn.addEventListener('click', openSettings);
        closeSettingsBtn.addEventListener('click', closeSettings);
        
        menuBtn.addEventListener('click', returnToMenu);
        menuBtnWin.addEventListener('click', returnToMenu);
        
        setTimeout(() => {
             resize();
             setTheme(activeTheme); // Initialize colors
        }, 100);

    </script>
</body>
</html>
